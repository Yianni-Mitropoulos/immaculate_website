<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Immaculate Language Homepage</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <nav id="navbar">
        __navbar_body
    </nav>
    <div id="content">

        <p>
            <em>Please note that Immaculate does not currently exist as software that can be used and downloaded; it's currently just a dream. This website was created to help attract the necessary talent to begin making that dream a reality.</em>
        </p>

        <!-- INTRODUCTION -->
        <h1>Introduction</h1>

        <!-- Overview -->
        <h2>Overview</h2>
        <p>
            Immaculate is a stack-oriented imperative programming in which all types appear immutable from the standpoint of the developer and end-user. Reference counting is used to prevent memory leaks by ensuring that unused memory is reclaimed; additionally, when the reference count of an object drops to exactly 1, that object is regarded as mutable 'under the hood', allowing otherwise costly operations to be implemented more cheaply.
        </p>
        <p>
            The language is strongly and statically-typed; this helps catch bugs early, to promote fast execution, and to assist with code analysis. It is also JIT-compiled; this helps to facilitate code use and reuse without the significant runtime cost of a fully interpreted architecture. Additionally, note that I/O in Immaculate is tightly controlled and fully encapsulated. The I/O calls a function is able to make are completely tracked within its type signature, and these calls always work by sending one or more requests to the parent context, which is free to handle these requests however it pleases. Like most of the features that make Immaculate special, this promotes code reuse and analysis, helps the builder produce more efficient and optimized code than would otherwise be possible, and supports secure programming practices.
        </p>
        <p>            
            Furthermore, I/O is the only way to get information out of non-terminating computatons in Immaculate. This means that all non-terminating pure functions in Immaculate are essentially the same, since they simply keep running unproductively until the executing context is paused or deallocated. Note that this is contrary to the current design of the Haskell programming language, in which monads and laziness allow non-terminating pure functions to nevertheless emit data that can be seen by the outside world. This design decision is based partly on a healthy respect for the principle of least astonishment, and partly on a desire for the category of Immaculate types and Immaculate pure functions to more closely resemble the category of sets and partial functions, thereby facilitating mathematical analysis.
        </p>
        <p>
            Immaculate has no keywords. Instead, functions can be given both runtime and build-time arguments. This 'two-factor' model ensures that functions in Immaculate are nearly as expressive as keywords in other, competing frameworks. The main difference, of course, is that competing frameworks are usually stuck with a fixed set of keywords, while in Immaculate you can effectively define your own keywords, albeit with some limits. For example, there is no way to write a 'return' function in Immaculate. The second dot point in the next paragraph clarifies why these limits exist somewhat.
        </p>
        <p>
            We've mentioned a few times that code analysis is easier in Immaculate. One reason for this is that it enjoys the property of <em>bijective substitutionality</em>. This means two things:
            <ul>
                <li>
                    Firstly, you can always take an instance of a function call in a block of code, and replace that call with the body of the function that's being called, and the new program will have exactly the same behaviour as the old program. This is called <em>forward substitutionality</em>, and has myriad theoretical and practical benefits.
                </li>
                <li>
                    Secondly, you can always take a well-formed expression from within an Immaculate function, stick that expression inside a function, and simply call that function in the location where that code used to be. This is called <em>backward substitutionality</em>, and it's possible because certain control-flow patterns available in other languages are not available in Immaculate. For example, although Immaculate supports both selection and looping (both bounded and unbounded), it does not have a 'return' function.
                </li>
            </ul>
        </p>
        <p>
            Mathematical proofs are first class citizens in Immaculate, and can be used to avoid the runtime costs associated with out-of-bounds checking. For example, if a developer uses a command that accesses a list by index, they must either provide a proof that this access attempt will within the bounds of the list, or else they must provide code to handle the event that such an access fails, while accepting the runtime cost of out-of-bounds checking.
        </p>
        <p>
            Some Immaculate values carry a pointer to a dictionary that can be used to store past computations associated with that value. For example, functions can cache past computations, while large integers can cache prime factorizations. This makes apparently naive design patterns much more efficient, and simplifies the process of efficient code design.
        </p>
        <p>
            A language is <em>homoiconic</em> if a program written in that language can be straightforwardly manipulated as data using the language. Immaculate is designed to be as homoiconic as possible. This means that Immaculate functions are implemented as Immaculate lists of Immaculate commands. To promote efficiency, the needed JIT-compilation information attached to that list's cache, ensuring that the machine code does not have to be constructed anew each time.
        </p>
        <p>
            In the realm of modern programming language design, lexical scope is prevalent, confining variable visibility to the defining block and its sub-blocks. This standard approach, while providing structure, often inadvertently propagates functional impurities across extensive codebases. For instance, a function defined within a particular scope can influence variables within that scope irrespective of its invocation context, leading to widespread side effects and complexities that detract from clean, controlled, and encapsulated design principles described in the above paragraphs.
        </p>
        <p>
            Immaculate challenges this norm by adopting a dynamic scoping model, in which variable scope is determined by the context in which a function is called, not where it is defined. This approach might initially surprise seasoned developers accustomed to lexical scoping. However, it's crucial to consider the distinct advantages that dynamic scoping brings to Immaculate. For example, it results in the property of bijective substitutability (see below), tightens control over side effects, boosts code reusability, and simplifies mathematical analysis. These benefits arise partly as a result of the straightforward category-theoretic semantics for dynamic variable scope, thereby providing a theoretically sound basis for this noteworthy departure from standard programming language design principles.
        </p>
        <p>            
            While this shift in scoping strategy marks a departure from conventional practices, it aligns with Immaculate's goals of achieving a more modular, maintainable, and theoretically cohesive programming environment. We invite developers to explore this model further to understand how it can lead to more predictable and manageable code, contrary to initial perceptions.
        </p>
        <p>
            Every Immaculate value can be stored to disk, with the specific storage strategy controlled by the platform. For example, values of type 'img' can be stored, with the platform being configurable to use PNG, WEBP, or some combination of the two. In a similar way, many (but not all) values can be shared to untrusting third-parties, with the format used for transmission negotiated by the relevant computers.
        </p>
        <p>
            Note that Immaculate is more than just a programming language. It's also a platform to help users store, search, version, backup, and share their data. To make a value persistent, the user might e.g. drag and drop it into their file system, or mark it as persistent, or something like that, with the details depending on the default GUI that's ultimately settled upon. Both algorithmic and user-generated tags help users find their data, and multiple values can be bundled together into a single 'file' whose values represent different versions of the same data. Such files can be made available across multiple different computers and even multiple users by paying the market price for this service. Meanwhile, users can generate income by supplying their bandwidth and disk space for use by other Immaculate machines.
        </p>

        <!-- Goals and Strategy -->
        <h2>Goals and Strategy</h2>
        <p>
            As should be clear from the previous subsection, Immaculate is a very-high-level language (VHLL) that's designed to address the biggest issues with that genre of language, both from the standpoint of the developer and from the standpoint of the end-user. The long-term goal is to compete with and ultimately displace currently-popular like Python, Java, Go, and maybe even JavaScript. To achieve this goal, the broader strategy is to:
            <li> Attract talented thinkers. </li>
            <li> Display a healthy respect for the core insights of pure mathematics. </li>
            <li> Do things at the right level of abstraction. </li>
            <li> Keep both the software developer and the end-user in mind at all times. </li>
            <li> Take our sweet time. </li>
        </p>
        <p>
            By taking our time, we can better leverage the creativity and critical thinking skills of our contributors, innovate effectively, develop appropriate abstractions, and avoid the numerous mistakes of numerous competing platforms and frameworks.
        </p>

        <h2>3+1 Different Languages</h2>
        <p>
            Immaculate encompasses three distinct layers of language, the last of which is Just-In-Time (JIT) compiled to machine code. Taken together, these four languages represent the full gamut of the intended development and deployment pipeline.
        </p>
        <ul>
            <li>
                <strong>Human-readable Immaculate:</strong> This is the high-level language that developers write. It includes abstract constructs like 'dictionary' and 'insert key-value pair'. Additionally, it can incorporate non-string embedded values, such as images, referenced by their local object IDs.
            </li>
            <li>
                <strong>Shareable Immaculate:</strong> When developers are ready to distribute their code, they convert it into this shareable format. Here, function names are transformed into Blake3 hash identifiers based on their definitions, and non-string values are also hashed. This hashed version facilitates secure peer-to-peer (P2P) sharing and verification, ensuring integrity and authenticity across distributed networks. Note that this level of code is still abstract, and deals with e.g. the general concept of a 'dictionary', as opposed to a concrete implementation via a specific hash table design.
            </li>
            <li>
                <strong>Actionable Immaculate:</strong> At the user's end, Shareable Immaculate is further compiled into Actionable Immaculate. This version replaces Blake3 hashes with local identifiers, fetches necessary dependencies, and selects specific implementations for abstract concepts mentioned in the human-readable version. It leverages mutable design patterns which are not possible in the earlier stages, thereby optimizing resource utilization.
            </li>
            <li>
                <strong>Machine Code:</strong> Finally, the actionable code is JIT-compiled into machine code as needed, which is executed by the user's computer. This final transformation allows the Immaculate program to run with an efficiency not too far below what might be achieved using a lower-level language like C or assembly.
            </li>
        </ul>

        <h1>Code Examples</h1>
        <h2>Hello, world!</h2>
        <p>
            The following code constructs the string value "Hello, world!". The constructed value can be handed to the file system for saving, or passed as input to another program or function:
            <pre><code>"Hello, world!"</code></pre>
        </p>
        <p>
            In general, I/O calls are preceded by the <code>@-</code> pattern. Thus, if instead of returning the string directly, you instead wish to log that string (with a linebreak at the end), you would instead write:
            <pre><code>@-println "Hello, world!"</code></pre>         
        </p>
        <p>
            The above code examples say "Hello, world!" at build-time. To say "Hello, world!" at runtime, we need to write a program. This can be achieved using the <code>class</code> function, like so:
            <pre><code># A simple "Hello, world!" program
class : $
  &#10;
  # An initializer for the class
  @-ini : $
    &#10;
    # An I/O call performed at program initialization
    @-println "Hello, world!"</code></pre>         
        </p>
    </div>
    <script src="js/script.js"></script>
</body>
</html>
