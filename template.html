<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Immaculate Language Homepage</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <nav id="navbar">
        __navbar_body
    </nav>
    <div id="content">

        <p>
            <em>Please note that Immaculate does not currently exist as software that can be used and downloaded; it's currently just a dream. This website was created to help attract the necessary talent to begin making that dream a reality.</em>
        </p>

        <!-- INTRODUCTION -->
        <h1>Introduction</h1>

        <!-- Overview -->
        <h2>Overview</h2>
        <p>
            Immaculate is a stack-oriented imperative programming in which all types appear immutable from the standpoint of the developer and end-user. Reference counting is used to prevent memory leaks by ensuring that unused memory is reclaimed; additionally, when the reference count of an object drops to exactly 1, that object is regarded as mutable 'under the hood', allowing otherwise costly operations to be implemented more cheaply.
        </p>
        <p>
            The language is strongly and statically-typed; this helps catch bugs early, to promote fast execution, and to assist with code analysis. It is also JIT-compiled; this helps to facilitate code use and reuse without the significant runtime cost of a fully interpreted architecture. Additionally, note that I/O in Immaculate is tightly controlled and fully encapsulated. The I/O calls a function is able to make are completely tracked within its type signature, and these calls always work by sending one or more requests to the parent context, which is free to handle these requests however it pleases. Like most of the features that make Immaculate special, this promotes code reuse and analysis, helps the builder produce more efficient and optimized code than would otherwise be possible, and supports secure programming practices.
        </p>
        <p>            
            Furthermore, I/O is the only way to get information out of non-terminating computatons in Immaculate. This means that all non-terminating pure functions in Immaculate are essentially the same, since they simply keep running unproductively until the executing context is paused or deallocated. Note that this is contrary to the current design of the Haskell programming language, in which monads and laziness allow non-terminating pure functions to nevertheless emit data that can be seen by the outside world. This design decision is based partly on a healthy respect for the principle of least astonishment, and partly on a desire for the category of Immaculate types and Immaculate pure functions to more closely resemble the category of sets and partial functions, thereby facilitating mathematical analysis.
        </p>
        <p>
            Immaculate has no keywords. Instead, functions can be given both runtime and build-time arguments. This 'two-factor' model ensures that functions in Immaculate are nearly as expressive as keywords in other, competing frameworks. The main difference, of course, is that competing frameworks are usually stuck with a fixed set of keywords, while in Immaculate you can effectively define your own keywords, albeit with some limits. For example, there is no way to write a 'return' function in Immaculate. The second dot point in the next paragraph clarifies why these limits exist somewhat.
        </p>
        <p>
            We've mentioned a few times that code analysis is easier in Immaculate. One reason for this is that it enjoys the property of <em>bijective substitutionality</em>. This means two things:
            <ul>
                <li>
                    Firstly, you can always take an instance of a function call in a block of code, and replace that call with the body of the function that's being called, and the new program will have exactly the same behaviour as the old program. This is called <em>forward substitutionality</em>, and has myriad theoretical and practical benefits.
                </li>
                <li>
                    Secondly, you can always take a well-formed expression from within an Immaculate function, stick that expression inside a function, and simply call that function in the location where that code used to be. This is called <em>backward substitutionality</em>, and it's possible because certain control-flow patterns available in other languages are not available in Immaculate. For example, although Immaculate supports both selection and looping (both bounded and unbounded), it does not have a 'return' function.
                </li>
            </ul>
        </p>
        <p>
            Mathematical proofs are first class citizens in Immaculate, and can be used to avoid the runtime costs associated with out-of-bounds checking. For example, if a developer uses a command that accesses list items by index, they must either provide a proof that these accesses are within the bounds of the list, or they must provide code to handle the event that such an access fails, while accepting the runtime cost of out-of-bounds checking.
        </p>
        <p>
            Mention homoiconicity.
        </p>
        <p>
            Mention OOP cautionism.
        </p>
        <p>
            In the realm of modern programming language design, lexical scope is prevalent, confining variable visibility to the defining block and its sub-blocks. This standard approach, while providing structure, often inadvertently propagates functional impurities across extensive codebases. For instance, a function defined within a particular scope can influence variables within that scope irrespective of its invocation context, leading to widespread side effects and complexities that detract from clean, controlled, and encapsulated design principles described in the above paragraphs.
        </p>
        <p>
            Immaculate challenges this norm by adopting a dynamic scoping model, in which variable scope is determined by the context in which a function is called, not where it is defined. This approach might initially surprise seasoned developers accustomed to lexical scoping. However, it's crucial to consider the distinct advantages that dynamic scoping brings to Immaculate. For example, it results in the property of bijective substitutability (see below), tightens control over side effects, boosts code reusability, and simplifies mathematical analysis. These benefits arise partly as a result of the straightforward category-theoretic semantics for dynamic variable scope, thereby providing a theoretically sound basis for this noteworthy departure from standard programming language design principles.
        </p>
        <p>            
            While this shift in scoping strategy marks a departure from conventional practices, it aligns with Immaculate's goals of achieving a more modular, maintainable, and theoretically cohesive programming environment. We invite developers to explore this model further to understand how it can lead to more predictable and manageable code, contrary to initial perceptions.
        </p>
        <p>
            Mention that Immaculate is more than just a programming language. It's also a platform to help users store, search, version, backup, and share their data.
        </p>

        <!-- Goals and Strategy -->
        <h2>Goals and Strategy</h2>
        <p>
            As should be clear from the previous subsection, Immaculate is a very-high-level language (VHLL) that's designed to address the biggest issues with that genre of language, both from the standpoint of the developer and from the standpoint of the end-user. The long-term goal is to compete with and ultimately displace currently-popular like Python, Java, Go, and maybe even JavaScript. To achieve this goal, the broader strategy is to:
            <li> Attract talented thinkers. </li>
            <li> Display a healthy respect for the core insights of pure mathematics. </li>
            <li> Do things at the right level of abstraction. </li>
            <li> Keep both the software developer and the end-user in mind at all times. </li>
            <li> Take our sweet time. </li>
        </p>
        <p>
            By taking our time, we can better leverage the creativity and critical thinking skills of our contributors, innovate effectively, develop appropriate abstractions, and avoid the numerous mistakes of numerous competing platforms and frameworks.
        </p>

        <!-- Three Different Languages -->
        <h2>Three Different Languages</h2>
        <p>
            According to the current plan, Immaculate is actually three different languages.
            <ul>
                <li>
                    Software developers write <strong>human-readable Immaculate</strong>.
                </li>
                <li>
                    When ready, they transpile this into <strong>group-level Immaculate</strong>, replacing function names with Blake3 identifiers to ensure that anyone within the target group can automatically download the functionality they need via a recursive process, facilitating easy install and P2P sharing within that group.
                </li>
                <li>
                    The computer of the end-user then transpiles this into a lower-level language called <strong>actionable Immaculate</strong>, which replaces the aforementioned Blake3 identifiers with more efficient nonhash identifiers, chooses concrete implementations for vaguely-defined functions like 'sort_list', and makes use of mutable design patterns that are not available in either of the other two versions of the language. The computer of the end-user then runs the program under question by JIT-compiling actionable Immaculate as needed.
                </li>
            </ul>
        </p>

        <h2>Examples</h2>
        <h3>What the language aims to achieve...</h3>

        <!-- Syntax -->
        <h1>Syntax</h1>
        <h2>Basics</h2>
        <p>Basic syntax rules...</p>
        <h2>Advanced</h2>
        <p>Advanced features...</p>

        <!-- Examples -->
        <h1>Examples</h1>
        <h2>Simple Examples</h2>
        <p>Simple code examples...</p>
        <h2>Complex Examples</h2>
        <p>More complex usage...</p>

    </div>
    <script src="js/script.js"></script>
</body>
</html>
